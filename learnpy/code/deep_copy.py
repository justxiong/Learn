#!/usr/bin/env python
# coding=utf-8
import copy
D1 = {'user': 'runoob', 'num': [1, 2, 3]} # 原始数据
D2 = D1  # 直接引用：D2和D1整体指向同一对象。
D3 = D1.copy()  # 浅拷贝：D3和D1的父对象是一个独立的对象，但是他们的子对象还是指向同一对象。
D4 = copy.deepcopy(D1)  # 深拷贝：D4和D1的整体是一个独立的对象。

D1['user'] = 'root' # 修改父对象D1
#D1['num'].remove(1) # 修改父对象D1中的[1, 2, 3]列表子对象
D1['num'][2]=5 # 修改父对象D1中的[1, 2, 3]列表子对象

print('原始数据:',{'user': 'runoob', 'num': [1, 2, 3]}) # 原始数据
print('改后数据:',D1) # 父子都修改过的
print('直接引用:',D2) # 父子都变(直接引用)
print('浅拷贝:',D3) # 父不变，子变(浅拷贝)
print('深拷贝:',D4) # 父子都不变(深拷贝)
#d2 d1赋值，指向相同内存空间，总保持相同

#原子类型:数值字符串等
#容器类型:元组列表字典等

#浅拷贝中目标对象与源对象是不同的对象，但目标对象中子(容器类型)对象与源对象中子容器类型对象是同一个对象
#d3 是d1的浅拷贝，d3的父对象即d3这个字典对象与d1是两个独立的对象,d3['num']是一个子(容器类型)对象与源对象中d1['num']是同一个对象，即   d3!不是d1 d3['user']/d1['user']是原子类型拷贝后都是对立的对象　d3['num']是d1['num']

#深拷贝中父对象得到的目标父对象子对象都与源父子对象对立

#https://www.cnblogs.com/wushuaishuai/p/7737865.html
#https://www.cnblogs.com/no-tears-girl/p/7592990.html
